hist(Prewt, freq = F, col = "pink",
xlab = "体重（lbs）", family = "Arial",
main = "治疗前体重分布直方图",
las = 1) # 将纵轴的刻度标签横向显示
windowsFonts(Song = windowsFont("Sinsum"))
loadfonts(device = "win")
hist(Prewt, freq = F, col = "pink",
xlab = "体重（lbs）", family = "Song",
main = "治疗前体重分布直方图",
las = 1) # 将纵轴的刻度标签横向显示
windowsFonts(Song = windowsFont("Microsoft YaHei UI"))
loadfonts(device = "win")
hist(Prewt, freq = F, col = "pink",
xlab = "体重（lbs）", family = "Song",
main = "治疗前体重分布直方图",
las = 1) # 将纵轴的刻度标签横向显示
# 设置字体显示
windowsFonts(Song = windowsFont("Times New Roman")) # 到“C:\Windows\Fonts”找
loadfonts(device = "win")
hist(Prewt, freq = F, col = "pink",
xlab = "体重（lbs）", family = "Song",
main = "治疗前体重分布直方图",
las = 1) # 将纵轴的刻度标签横向显示
# 设置字体显示
windowsFonts(Song = windowsFont("Microsoft YaHei UI")) # 到“C:\Windows\Fonts”找
loadfonts(device = "win")
hist(Prewt, freq = F, col = "pink",
xlab = "体重（lbs）", family = "Song",
main = "治疗前体重分布直方图",
las = 1) # 将纵轴的刻度标签横向显示
lines(density(Prewt), col = "blue", lwd = 2)
rug(Prewt)
detach(anorexia)
# 条形图（bar chart）
library(vcd)
data("Arthritis")
attach(Arthritis)
counts <- table(Improved)
counts
barplot(counts, xlab = "Improvement", ylab = "Frequency", las = 1)
counts <- table(Improved, Treatment)
counts
barplot(counts,
col = c("red", "green", "blue"),
xlab = "Improvement", ylab = "Frequency",
beside = T, las = 1)
legend("top", legend = rownames(counts),
fill = c("red", "yellow", "green"))
# 让条形图显示更多的统计数据
library(epiDisplay)
aggregate.plot(anorexia$Postwt, by = list(anorexia$Treat),
error = "sd", legend = F,
bar.col = c("red", "green", "blue"),
ylim = c(0, 100), las = 1,
main = "")
# 饼图（pie chart）
percent <- c(5.8, 27.0, 0.5, 20.8, 12.8, 33.1)
sum(percent[i])
length(percent)
percent[1]
class(length(percent))
sum(percent)
diseases <- c("上感", "中风", "外伤", "晕厥", "食物中毒", "其他")
lbs <- paste0(diseases, percent, "%")
pie(percent, labels = lbs, col = rainbow(6))
diseases <- c("上感", "中风", "外伤", "晕厥", "食物中毒", "其他", family = "Song")
lbs <- paste0(diseases, percent, "%")
pie(percent, labels = lbs, col = rainbow(6))
# 设置字体显示
windowsFonts(Song = windowsFont("Microsoft YaHei UI")) # 到“C:\Windows\Fonts”找
diseases <- c("上感", "中风", "外伤", "晕厥", "食物中毒", "其他", family = "Song")
lbs <- paste0(diseases, percent, "%")
pie(percent, labels = lbs, col = rainbow(6))
pie(percent, labels = lbs, col = rainbow(6), family = "Song")
pie(percent, labels = lbs, col = rainbow(6),radius = 2, family = "Song")
pie(percent, labels = lbs, col = rainbow(6),radius = 1.5, family = "Song")
pie(percent, labels = lbs, col = rainbow(6),radius = 1, family = "Song")
pie(percent, labels = lbs, col = rainbow(6),radius = 1.2, family = "Song")
pie(percent, labels = lbs, col = rainbow(6),radius = 1.1, family = "Song")
pie(percent, labels = lbs, col = rainbow(6),radius = 1.05, family = "Song")
pie(percent, labels = lbs, col = rainbow(6), cex = 1.5, radius = 1.05, family = "Song")
pie(percent, labels = lbs, col = rainbow(6),
cex = 1, radius = 1.05, family = "Song") # radius调整半径，cex调整字体大小
# 无序多分类logistic回归
library(epiDisplay)
data("Ectopic")
str(Ectopic)
library(nnet)
multil <- multinom(outc ~ hia, data = Ectopic)
summary(multil)
st <- summary(multil))$standard.errors
st <- summary(multil)$standard.errors
z <- coef(multil) / st
z
p.values <- pnorm(abs(z), lower.tail = F) * 2
p.values
confint(multil)
exp(confint(multil))
library(epiDisplay)
mlogit.display(multil)
# 把另一个变量gravi也放入模型中
multil2 <- multinom(outc ~ hia + gravi, data = Ectopic)
summary(multil2)
mlogit.display(multil2)
AIC(multil, multil2)
dat <- as.array(c(10, 7, 19, 6, 0, 2, 7, 5, 1, 5, 6, 16),
dim = c(2, 2, 3),
dimnames = list(method = c("old", "new"),
sex = c("male", "female"),
outcome = c("effectiveless", "effective",
"recover")))
dat <- as.table(dat)
data1 <- as.data.frame(dat)
data1
dat <- as.array(c(10, 7, 19, 6, 0, 2, 7, 5, 1, 5, 6, 16),
dim = c(2, 2, 3),
dimnames = list(method = c("old", "new"),
sex = c("male", "female"),
outcome = c("effectiveless", "effective",
"recover")))
dat <- as.table(dat)
data1 <- as.data.frame(dat)
data1
str(data1)
View(data1)
dat <- array(c(10, 7, 19, 6, 0, 2, 7, 5, 1, 5, 6, 16),
dim = c(2, 2, 3),
dimnames = list(method = c("old", "new"),
sex = c("male", "female"),
outcome = c("effectiveless", "effective",
"recover")))
dat <- as.table(dat)
data1 <- as.data.frame(dat)
data1
str(data1)
View(data1)
data1$outcome <- ordered(data1$outcome)
data1$outcome
library(MASS)
polr1 <- polr(outcome ~ sex + method, weights = Freq, data = data1)
summary(polr1)
install.packages("VGAM")
# 对模型的平行性假设做检验
library(VGAM)
data2 <- data1[rep(1:nrow(data1), data1$Freq), -4]
head(data2)
head(data1)
str(data2)
polr2 <- polr(outcome ~ sex, weights = Freq, data = data2)
polr2 <- polr(outcome ~ sex, data = data2)
summary(polr2)
exp(coef(polr2))
exp(confint(polr2))
polr.p <- vglm(outcome ~ sex + method,
family = cumulative(parallel = T),
data = data2)
polr.np <- vglm(outcome ~ sex + method,
family = cumulative(parallel = F),
data = data2)
VAGM::LRtest(polr.p, polr.np)
VGAM::LRtest(polr.p, polr.np)
VGAM::Lrtest(polr.p, polr.np)
VGAM::lrtest(polr.p, polr.np)
ordinal.or.display(polr1)
rm(list = ls())
install.packages("robust")
# Poisson回归处理结果变量为计数的资料
library(robust)
data("breslow.dat")
str(breslow.dat)
summary(breslow.dat)
breslow <- breslow.dat[, 6:9]
summary(breslow)
# 直方图查看分布
hist(breslow$Ysum, breaks = 20,
main = "Distribution of Seizure Count",
xlab = "Seizure Count")
fit <- glm(Ysum ~ Base + age + Trt, data = breslow.dat,
family = poisson)
fit <- glm(Ysum ~ Base + Age + Trt, data = breslow.dat,
family = poisson)
summary(fit)
coef(fit)
exp(coef(fit))
exp(confint(fit))
library(epiDisplay)
idr.display(fit, digits = 3))
idr.display(fit, digits = 3)
idr.display(fit)
install.packages("qcc")
# 过度离散的判定及处理
library(qcc)
# 基础图形系统实现
par(bg = "white", mar = rep(0,4))
plot(1, type = "n", xlim = c(0,1), ylim = c(0,1), axes = FALSE, ann = FALSE)
# 绘制主体结构
line_col <- "#6A0DAD" # 紫色
y_seq <- seq(0.3, 0.7, length.out = 7) # 垂直方向定位点
# 左侧垂直结构
segments(x0 = 0.35, y0 = y_seq, x1 = 0.4, y1 = y_seq, col = line_col, lwd = 3)
segments(x0 = 0.4, y0 = min(y_seq), x1 = 0.4, y1 = max(y_seq), col = line_col, lwd = 3)
# 右侧垂直结构（对称）
segments(x0 = 0.6, y0 = y_seq, x1 = 0.65, y1 = y_seq, col = line_col, lwd = 3)
segments(x0 = 0.6, y0 = min(y_seq), x1 = 0.6, y1 = max(y_seq), col = line_col, lwd = 3)
# 水平连接线
segments(x0 = 0.4, y0 = 0.3, x1 = 0.6, y1 = 0.3, col = line_col, lwd = 3)
segments(x0 = 0.4, y0 = 0.7, x1 = 0.6, y1 = 0.7, col = line_col, lwd = 3)
# 添加文字
text(x = 0.5, y = c(0.6, 0.5, 0.4), labels = "C",
col = line_col, cex = 2, font = 2)
# 使用grid包实现的另一种方式（可选）
library(grid)
grid.newpage()
grid.rect(gp = gpar(fill = "white", col = NA))
# 定义紫色样式
purple_line <- gpar(col = "#6A0DAD", lwd = 3)
# 绘制左侧结构
grid.polyline(x = unit.c(rep(unit(0.35, "npc"), 7),
rep(unit(0.4, "npc"), 7)),
y = unit(rep(seq(0.3, 0.7, length.out = 7), 2), "npc"),
id = rep(1:7, 2),
gp = purple_line)
# 绘制右侧结构（镜像对称）
grid.polyline(x = unit.c(rep(unit(0.65, "npc"), 7),
rep(unit(0.6, "npc"), 7)),
y = unit(rep(seq(0.3, 0.7, length.out = 7), 2), "npc"),
id = rep(1:7, 2),
gp = purple_line)
# 添加连接线
grid.segments(x0 = 0.4, x1 = 0.6, y0 = 0.3, y1 = 0.3, gp = purple_line)
grid.segments(x0 = 0.4, x1 = 0.6, y0 = 0.7, y1 = 0.7, gp = purple_line)
# 添加文字
grid.text(label = "C\nC\nC", x = 0.5, y = 0.5,
gp = gpar(col = "#6A0DAD", fontsize = 24, fontface = "bold"))
# 基础图形系统实现
par(bg = "white", mar = rep(0,4))
plot(1, type = "n", xlim = c(0,1), ylim = c(0,1), axes = FALSE, ann = FALSE)
# 绘制主体结构
line_col <- "#6A0DAD" # 紫色
y_seq <- seq(0.3, 0.7, length.out = 7) # 垂直方向定位点
# 左侧垂直结构
segments(x0 = 0.35, y0 = y_seq, x1 = 0.4, y1 = y_seq, col = line_col, lwd = 3)
segments(x0 = 0.4, y0 = min(y_seq), x1 = 0.4, y1 = max(y_seq), col = line_col, lwd = 3)
# 右侧垂直结构（对称）
segments(x0 = 0.6, y0 = y_seq, x1 = 0.65, y1 = y_seq, col = line_col, lwd = 3)
segments(x0 = 0.6, y0 = min(y_seq), x1 = 0.6, y1 = max(y_seq), col = line_col, lwd = 3)
# 水平连接线
segments(x0 = 0.4, y0 = 0.3, x1 = 0.6, y1 = 0.3, col = line_col, lwd = 3)
segments(x0 = 0.4, y0 = 0.7, x1 = 0.6, y1 = 0.7, col = line_col, lwd = 3)
# 添加文字
text(x = 0.5, y = c(0.6, 0.5, 0.4), labels = "C",
col = line_col, cex = 2, font = 2)
# 使用grid包实现的另一种方式（可选）
library(grid)
grid.newpage()
grid.rect(gp = gpar(fill = "white", col = NA))
# 定义紫色样式
purple_line <- gpar(col = "#6A0DAD", lwd = 3)
# 绘制左侧结构
grid.polyline(x = unit.c(rep(unit(0.35, "npc"), 7),
rep(unit(0.4, "npc"), 7)),
y = unit(rep(seq(0.3, 0.7, length.out = 7), 2), "npc"),
id = rep(1:7, 2),
gp = purple_line)
# 绘制右侧结构（镜像对称）
grid.polyline(x = unit.c(rep(unit(0.65, "npc"), 7),
rep(unit(0.6, "npc"), 7)),
y = unit(rep(seq(0.3, 0.7, length.out = 7), 2), "npc"),
id = rep(1:7, 2),
gp = purple_line)
# 添加连接线
grid.segments(x0 = 0.4, x1 = 0.6, y0 = 0.3, y1 = 0.3, gp = purple_line)
grid.segments(x0 = 0.4, x1 = 0.6, y0 = 0.7, y1 = 0.7, gp = purple_line)
# 添加文字
grid.text(label = "胡\n志\n文", x = 0.5, y = 0.5,
gp = gpar(col = "#6A0DAD", fontsize = 24, fontface = "bold"))
qcc.overdispersion.test(breslow$Ysum, type = "poisson")
library(epiDisplay)
poisgof(fit)
# 1. 使用负二项分布
library(MASS)
fit2 <- glm.nb(Ysum ~ Base + Age + Trt, data = breslow.dat)
summary(fit2)
coef(fit2)
exp(coef(fit2))
exp(confint(fit2))
# 2. 使用广义估计方程
library(geepack)
install.packages("geepack")
# 2. 使用广义估计方程
library(geepack)
fit3 <- geeglm(Ysum ~ Base + Age + Trt, data = breslow.dat,
family = poisson, id = id, corstr = "exchangeable")
fit2 <- glm.nb(Ysum ~ Base + Age + Trt, data = breslow)
summary(fit2)
fit3 <- geeglm(Ysum ~ Base + Age + Trt, data = breslow,
family = poisson, id = id, corstr = "exchangeable")
View(breslow)
# 3. 使用广义线性混合模型
library(lme4)
fit4 <- glmer(Ysum ~ Base + Age + Trt + (1 | id),
data = breslow.dat, family = poisson)
fit3 <- geeglm(Ysum ~ Base + Age + Trt, data = breslow,
family = poisson, corstr = "exchangeable")
# 2. 使用拟Poissom回归
fit.od <- glm(Ysum ~ Base + Age + Trt,
data = breslow,
family = quasipoisson)
summary(fit.od)
poisgof(fit.od)
poisgof(fit.nb)
poisgof(fit2)
getwd()
setwd("D:/R/draft")
getwd()
library(survival)
data(ovarian)
head(ovarian)
data(ovarian)
View(ovarian)
data(ovarian))
data(ovarian)
str(ovarian)
# 把后3个变量转换成因子
ovarian$resid.ds <- factor(ovarian$resid.ds,
levels = c(1, 2),
labels = c("no", "yes"))
ovarian$rx <- factor(ovarian$rx,
levels = c(1, 2),
labels = c("A", "B"))
ovarian$ecog.ps <- factor(ovarian$ecog.ps,
levels = c(1, 2),
labels = c("good", "bad"))
hist(ovarian$age)
ovarian$agegr <- cut(ovarian$age,
breaks = c(0, 50, 75),
labels = c("<=50", ">50"))
table(ovarian$agegr)
# 创建生存对象
surv.obj <- Surv(time = ovarian$futime,
event = ovarian$fustat)
surv.obj
# 生存率的估计与生存曲线
survfit.obj <- survfit(surv.obj ~ 1)
summary(survfit.obj)
summary(survfit.obj, censored = T)
plot(survfit.obj,
xlab = "Time in days",
ylab = "Survival probability",
main = "Kaplan-Meier survival curve for ovarian cancer patients")
plot(survfit.obj, mark.time = T,
xlab = "Time in days",
ylab = "Survival probability",
main = "Kaplan-Meier survival curve for ovarian cancer patients")
# 虚线表示置信区间，如果不想显示置信区间，可以设置conf.int = F
plot(survfit.obj, mark.time = T, conf.int = F,
xlab = "Time in days",
ylab = "Survival probability",
main = "Kaplan-Meier survival curve for ovarian cancer patients")
# 生存率的比较
surv.treat <- survfit(surv.obj ~ rx, data = ovarian)
summary(surv.treat)
plot(surv.treat, mark.time = T,
xlab = "Time in days",
ylab = "Survival probability",
main = "Kaplan-Meier survival curve for ovarian cancer patients by treatment",
col = c("red", "blue"),
lty = 1:2)
legend("topright",
legend = c("A", "B"),
col = c("red", "blue"),
lty = 1:2,
bty = "n")
install.packages("survminer")
library(survminer)
ggsurvplot(surv.treat,
data = ovarian,
risk.table = T, # 添加风险表
pval = T, # 添加p值
conf.int = T, # 添加置信区间
xlab = "Time in days",
ylab = "Survival probability",
title = "Kaplan-Meier survival curve for ovarian cancer patients by treatment",
legend.title = "Treatment",
legend.labs = c("A", "B"),
palette = c("red", "blue"))
ggsurvplot(surv.treat,
data = ovarian,
risk.table = F, # 添加风险表
pval = T, # 添加p值
conf.int = T, # 添加置信区间
xlab = "Time in days",
ylab = "Survival probability",
title = "Kaplan-Meier survival curve for ovarian cancer patients by treatment",
legend.title = "Treatment",
legend.labs = c("A", "B"),
palette = c("red", "blue"))
plot(surv.treat, mark.time = T, conf.int = T,
xlab = "Time in days",
ylab = "Survival probability",
main = "Kaplan-Meier survival curve for ovarian cancer patients by treatment",
col = c("red", "blue"),
lty = 1:2)
# 时序检验
survdiff(surv.obj ~ rx, data = ovarian)
cox1 <- coxph(surv.obj ~ rx + resid.ds + agegr + ecog.ps, data = ovarian)
summary(cox1)
drop1(cox1, test = "Chisq") # 检验变量的显著性
# ecog.ps的p值最大，将其从模型中去掉
cox2 <- coxph(surv.obj ~ rx + resid.ds + agegr, data = ovarian)
summary(cox2)
step.cox <- step(cox1) # 逐步回归
summary(step.cox)
# Cox比例风险模型的假设检验
# Cox比例风险模型的假设检验主要是检验比例风险假设是否成立
# 比例风险假设是指不同组之间的生存函数比值是恒定的
cox.zph(cox2) # 检验比例风险假设
# 生存的预测
newdata <- data.frame(rx = c("A", "B"),
resid.ds = c("no", "no"),
agegr = c(">50", ">50"))
newdata
hr <- predict(cox2, newdata = newdata, type = "risk")
hr
hr[1] / hr[2] # 计算风险比
cox.fit <- survfit(cox2, newdata = newdata, type = "Kaplan-Meier")
summary(cox.fit)
cox.fit <- survfit(cox2, newdata = newdata, type = "Kaplan-Meier")
library(survival)
cox.fit <- survfit(cox2, newdata = newdata, type = "Kaplan-Meier")
plot(cox.fit, mark.time = T, conf.int = T,
xlab = "Time in days",
ylab = "Survival probability",
main = "Kaplan-Meier survival curve for ovarian cancer patients by treatment",
col = c("red", "blue"),
lty = 1:2)
install.packages("flexclust")
# Q型聚类
library(flexclust)
data("nutrient")
head(nutrient)
row.names(nutrient) <- tolower(row.names(nutrient))
row.names()
row.names(nutrient)
str(nutrient)
summary(nutrient)
nutrient.scaled <- scale(nutrient)
d.eu <- dist(nutrient.scaled, method = "euclidean")
hc1 <- hclust(d.eu, method = "average")
plot(hc1, hang = -1, labels = row.names(nutrient),
main = "Hierarchical clustering with average linkage",
xlab = "", ylab = "")
rect.hclust(hc1, k = 5, border = "red") # 画出4个聚类的矩形框
rect.hclust(hc1, k = 5) # 画出4个聚类的矩形框
install.packages("NbClust")
library(NbClust)
# 选择最优的聚类数
NbClust(nutrient.scaled,
distance = "euclidean",
method = "average")
cutree(hc1, k = 5) # 切割树状图，得到5个聚类
data.frame(group = sort(cutree(hc1, k = 5))) # 查看每个聚类的成员
# R型聚类
library(cluster)
library(fpc)
install.packages("fpc")
library(fpc)
data("iris")
head(iris)
# 只选择数值型变量
iris.num <- iris[, -5]
# 计算距离矩阵
d.eu <- dist(iris.num, method = "euclidean")
# 计算K均值聚类
k.means <- kmeans(iris.num, centers = 3, nstart = 20)
# 计算K均值聚类的轮廓系数
silhouette.kmeans <- silhouette(k.means$cluster, d.eu)
plot(silhouette.kmeans,
main = "Silhouette plot for K-means clustering",
col = 1:3,
border = NA)
plot(silhouette.kmeans,
main = "Silhouette plot for K-means clustering",
col = 1:3,
border = NA)
plot(silhouette.kmeans,
main = "Silhouette plot for K-means clustering",
col = 1:3,
border = NA)
# 计算K均值聚类的轮廓系数
silhouette.kmeans <- silhouette(k.means$cluster, d.eu)
# R型聚类
library(cluster)
library(fpc)
data("iris")
head(iris)
# 只选择数值型变量
iris.num <- iris[, -5]
# 计算距离矩阵
d.eu <- dist(iris.num, method = "euclidean")
# 计算R均值聚类
pam.kmeans <- pam(iris.num, k = 3)
# 计算R均值聚类的轮廓系数
silhouette.pam <- silhouette(pam.kmeans$clustering, d.eu)
plot(silhouette.pam,
main = "Silhouette plot for PAM clustering",
col = 1:3,
border = NA)
plot(silhouette.pam,
main = "Silhouette plot for PAM clustering",
col = 1:3,
border = NA)
